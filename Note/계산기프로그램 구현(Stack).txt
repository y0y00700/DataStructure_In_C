스택을 활용한 계산기 프로그램 구현

사칙연산을 계산할수 있는 프로그램을 작성해야함.

예시) 
(3+4) * (5/2) + (7 + (9-5))

두가지의 고려가 필요
1. 소괄호를 파악하여 그 부분을 먼저 연산한다.
2. 연산자의 우선순위를 근거로 연산의 순위를 결정해야 한다.

계산기 구현에 필요한 알고리즘은 스택과는 별개
다만, 그 알고리즘의 구현에 있어서 스택이 매우 요긴하게 활용됨.

세 가지 수식의 표기법: 전위 , 중위 , 후위

중위 표기법(infix notation) ex) 5 + 2 / 7
수식 내에 연산의 순서에 대한 정보가 담겨 있지 않다.
그래서 소괄호와 연산자의 우선 순위라는 것을 정의하여 이를
기반으로 연산의 순서를 명시한다.

전위 표기법(prefix notaion) ex) + 5 / 2 7
수식 내에 연산의 순서에 대한 정보가 담겨있다.
그래서 소괄호가 필요 없고 연산의 우선순위를 결정할 필요도 없다.

후위 표기법(postfix notation) ex) 5 2 7 / +
전위 표기법과 마찬가지로 수식 내에 연산의 순서에 대한 정보가 담겨있다.
그래서 소괄호가 필요 없고 연산의 우선순위를 결정할 필요도 없다.

소괄호와 연산자의 우선순위를 인식하게 하여 중위 표기법의 수식을 직접 계산하게 프로그래밍
하는 것 보다 후위 표기법의 수식을 계산하도록 프로그래밍 하는 것이 더 쉽다.

후위 표기법 계산기 프로그래밍을 우선 작성 (제일 쉽다.)
이후, 중위 표기법 ->후위 표기법 수식으로 바꾸는 것 (함수)

최종적으로 중위 표기법이 가능한 프로그래밍으로 전환

중위 -> 후위 : 소괄호 고려하지 않고

원본 : 5 + 2 / 7
수식을 이루는 왼쪽 문자부터 시작해서 하나씩 처리해 나간다.
변환: 5 O O O O 
쟁반 : + 
피 연산자를 만나면 무조건 변환된 수식이 위치할 자리로 이동시킨다.
변환: 5 2 O O O
        /
쟁반: + 

** / 연산자의 우선순휘가 높으므로 + 연산자 위에 올린다.

쟁반에 위치한 연산자의 우선순위가 높다면 
  - 쟁반에 위치한 연산자를 꺼내서 변환된 수식이 위치할 자리로 옮긴다.
  - 그리고 새 연산자는 쟁반으로 옮긴다.
쟁반에 위치한 연산자의 우선순위가 낮다면
  - 쟁반에 위치한 연산자의 위에 새 연산자를 쌓는다.

변환 : 5 2 7 O O 
        /
쟁반 : +

쟁반에 쌓인 연산자를 차례대로 꺼내어 변환위치에 위치시킨다.

최종 변환 : 5 2 7 / +

변환 규칙 정리
피 연산자는 그냥 옮긴다.
연산자는 쟁반으로 옮긴다.
연산자가 쟁반에 있다면 우선순위를 비교하여 처리방법을 결정한다.
마지막까지 쟁반에 남아있는 연산자들은 하나씩 꺼내서 옮긴다.

중위 -> 후위 : 고민 될 수 있는 상황.

상황 1
+연산자가 쟁반에 있는데 -가 들어온 상황
결과: 
        + 
쟁반 : -
먼저 들어온 연산을 빼고 쟁반위에 후에 들어온 연산 넣는다.
(먼저 들어왔으므로)
즉, 연산자 우선순위가 동일하면 먼저 들어온 게 나중에 빠짐.
상황 2
쟁반에 2개의 연산자가 들어와 있을때, 제일 낮은 우선순위 연산자가 왔을때,
         /
쟁반:  +

두개다 빼고 맨 기저에 제일 낮은 놈을 넣는다.
       /
       +
쟁반: -

즉 연산자 우선순위가 정렬될때까지 비교가 필요하다!

** 연습문제 해보면 좋다.

중위 -> 후위 소괄호 고려 1

후위 표기법의 수식에서는 먼저 연산이 이뤄져야 하는 연산자가 
뒤에 연산이 이뤄지는 연산자보다 앞에 위치해야 한다.
따라서 소괄호 안에 있는 연산자들이 후위 표기법의 수식에서 앞부분에
위치해야 한다.
'(' 연산자의 우선순위는 그 어떤 사칙 연산자들보다 낮다고 간주! 그래서 ')'
연산자가 등장할 때까지 쟁반에 남아 소괄호의 경계 역할을 해야 한다.

예제) 
(1+2*3)/4

변환: 1 2 3 O O O O
       +
       *
tray : ( 
 
변환: 1 2 3 * + O O

tray : empty


변환 : 1 2 3 * + 4 O

tray : /

최종 : 1 2 3 * + 4 /


중위 -> 후위 : 프로그램 구현1

ConvToRPNExp의 첫 번째 helper Function

연산자 우선순위를 리턴
int GetOpPrec(char op){
	switch(op){
	case '*':
	case '/':
		return 5;
	case '+':
	case '-' :
		return 3;
	case '(':
		return 1;	
	}
	return -1;
}

두 연산자의 우선순위 비교 결과를 반환
int WhoPrecOp(char op1,char op2){
	int op1Prec = GetOpPrec(op1);
	int op2Prec = GetOpPrec(op2);
	if(op1Prec > op2Prec)
		return 1;   // 1번이 클때
	else if(op1Prec < op2Prec)
		return -1;  // 2번이 클때
	else return 0;         // 우선순위 동일
}


void ConvToRPNExp(char exp[]){
	Stack stack;
	int expLen = strlen(exp);
	char * convExp = (char*)malloc(expLen+1); // 변환 수식 담을 공간

	int i, idx = 0;
	char tok , popOp;

	memset(convExp,0,sizeof(char)*expLen+1); // 초기화
	StackInit(&stack);

	for(i=0;i<expLen;i++){	
		...
	}
	while(1SIsEmpty(&stack))
		convExp[idx++] = SPop(&stack);
	strcpy(exp, convEmp); // 변환된 수식을 반환
	free(convExp);
		
}
 
for문 내부

for(i=0;i<expLen;i++){
	tok = exp[i];
	if(isdigit(tok)){ // tok에 저장된 문자가 피연산자라면
		convExp[idx++] = tok;
	}else{
		switch(tok)
		{
			...
		}
	}
}

6번강의부터 이어서