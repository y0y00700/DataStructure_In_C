● 이진트리의 이해

이진 트리의 조건 : 
1. 루트 노드를 중심으로 두 개의 서브 트리로 나뉘어 진다.
2. 나뉘어진 두 서브 트리도 모두 이진 트리이어야 한다.

이진 트리가 되려면, 루트 노드를 중심으로 둘로 나뉘는 두개의 서브 트리도 이진트리이어야 하고,
그 서브 트리의 모든 서브 트리도 이진 트리이어야 한다.
(재귀적인 성향을 담아내지 못한 완전하지 않은 표현)

※ 트리의 구조는 재귀적이다.
   따라서 트리와 관련된 연산은 재귀적으로 사고하고 재귀적으로 구현할 필요가 있다.

● 이진 트리와 공집합 노드

공집합(empty set) 도 이진 트리에서는 노드로 간주한다.
-> 즉 한개의 자식만 생성되었을 때, 빈 공간의 공집합 노드(empty set)는 이진트리의 범주에서 벗어나지 않은 것으로 간주.
하나의 노드에 두 개의 노드가 달리는 형태의 트리는 모두 이진 트리이다.

● 레벨과 높이, 그리고 포화, 완전 이진 트리
 
루트 노드를 기준으로 0레벨에서 시작(트리의 높이와 레벨의 최대값은 같다!)

모든 레벨에 노드가 꽉 찬 트리 -> 포화 이진 트리
빈 틈 없이 차곡차곡 채워진 트리 -> 완전 이진 트리

완전 이진 트리는 위에서 아래로 왼쪽에서 오른쪽으로 채워진 트리를 의미
따라서, 포화 이진 트리는 동시에 완전 이진 트리이지만 역은 성립하지 않는다.

● 이진 트리의 구현

○ 이진트리 구현의 두가지 방법

 1) 배열 기반
   노드에 번호를 부여하고 그 번호에 해당하는 값을 배열의 인덱스 값으로 활용한다.
   편의상 배열의 첫 번째 요소는 사용하지 않는다.
  ※ 배열의 기본적인 장점 : 접근이 용이하다라는 특성이 트리에서도 그대로 반영된다.
     뿐만 아니라 배열을 기반으로 했을 때 완성하기 용이한 트리 관련 연산도 존재한다.
 2) 리스트 기반
   연결 리스트 기반에서는 트리의 구조와 리스트의 연결 구조가 일치한다.
   따라서 구현과 관련된 직관적인 이해가 더 좋은 편이다.
 
○ 헤더파일에 정의된 구조체의 이해
구조체 정의 
typedef struct _bTreeNode{
	BData data;
	struct _bTreeNode * left;
	struct _bTreeNode * right;
} BTreeNode;
이진트리의 모든 노드는 직/간접적으로 연결되어 있다.
따라서, 루트 노드의 주소 값만 기억하면, 이진 트리 전체를 가리키는 것과 다름이 없다.

논리적으로도 하나의 노드는 그 자체로 이진트리이다. 따라서 노드를 표현한 구조체는
실제로 이진 트리를 표현한 구조체가 된다.

왜 노드는 구조체로 정의하는데, 이진트리는 구조체 정의가 없는가?
ans : 이진트리의 노드이자 트리 자체이기 때문.

○ 헤더파일에 선언되는 함수들
BTreeNode * MakeTreeNode(void) // 노드 생성(데이터는 저장하지 않는다. left , right 모두 NULL로 초기화)
BTData GetData(BtreeNode * bt); // 노드에 저장된 데이터를 반환
void SetData(BTreeNode * bt,BTData data); // 노드에 데이터를 저장
(노드에 직접 접근하는 것보다 함수를 통한 접근이 더 좋은 구조이다.)

BTreeNode * GetLeftSubTree(BTreeNode * bt); // 왼쪽 서브 트리의 주소 값 반환.
BTreeNode * GetRightSubTree(BTreeNode * bt); // 오른쪽 서브 트리의 주소 값 반환.
루트 노드를 포함하여 어떠한 노드의 주소 값도 인자로 전달될 수 있다.
전달된 노드의 왼쪽,오른쪽 서브트리의 루트 노드 주소 값 또는 그냥 노드의 주소값이 반환된다.

void MakeLeftSubTree(BTreeNode * main, BTreeNode * sub); // main의 서브 왼쪽 서브 트리로 sub를 연결
void Make RightSubTree(BTreeNode * main, BTreeNode * sub); // main의 오른쪽 서브 트리로 sub를 연결
하나의 노드도 일종의 이진 트리이다. 따라서 위와 같이 함수를 이름짓는 것이 타당
위의 함수들은 단순히 노드가 아니라 트리를 대상으로도 그 결과를 보인다는 사실을 기억하자.

정의된 함수들의 이해를 돕는 main 함수
int main(void){
	BTreeNode * ndA = MakeBTreeNode(); // 노드 A 생성
	BTreeNode * ndB = MakeBTreeNode(); // 노드 B 생성
	BTreeNode * ndC = MakeBTreeNode(); // 노드 C 생성

	MakeLeftSubTree(ndA,ndB); // A 왼쪽에 B 연결
	MakeRightSubTree(ndA,ndC); // A 오른쪽에 C 연결

}

트리를 완전히 소멸시키는 방법은? -> 순회

