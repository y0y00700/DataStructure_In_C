복잡하지만 효율적인 정렬 알고리즘

1. 힙 정렬 알고리즘
: 힙의 특성을 활용하여, 힙에 정렬한 대상을 모두 넣었다가 다시 꺼내어 정렬을 진행!

int PriComp(int n1,int n2){
	return n2-n1; // 오름차순 정렬을 위한 문장
//	return n1-n2;
}

void HeapSort(int arr[],int n, PriorityComp pc){
	Heap heap;
	int i;

	HeapInit(&heap,pc);

	//정렬 대상을 가지고 힙을 구성
	for(i=0;i<n;i++)
		HInsert(&heap, arr[i]);

	//순서대로 하나씩 꺼내서 정렬 완성
	for(i=0;i<n;i++)
		arr[i] = HDelete(&heap);
}

성능평가
완전이진트리 -> O(log2N)의 복잡도

O(2log2N) 그런데 
앞의 2는 빅-오에서 무시가능하므로 O(nlog2N)

하나의 데이터를 넣었다가 빼므로 2n * log2N
상수 2는 무시
N개의 데이터에 대해 O(nlog2N) 이된다.

병합 정렬: Divide and Conquer (DAC)

1단계 분할(Divide) : 해결이 용이한 단계까지 문제를 분할해 나간다.
2단계 정복(Conquer) : 해결이 용이한 수준까지 분할된 문제를 해결한다.
3단계 결합(Combine) : 분할해서 해결한 결과를 결합하여 마무리한다.

병합 정렬 알고리즘 역시 DAC를 기반으로 설계된 알고리즘이다.

분할과정은 재귀적이다.

별도의 정렬을 진행하지 않아도 될 수준까지 분할을 진행

분할보다 신경 써야 하는 것이 병합 과정이다.
그래서 병합정렬이라 한다.

병합 정렬 : 재귀적 구현

void MergeSort(int arr[], int left, int right){
	int mid;
	if(left<right){ // left가 작거나 같으면 더 날눌 수 있다는 뜻
		//중앙 계산.
		mid = (left+right)/2;
		MergeSort(arr,left,mid); // left~mid에 위치한 데이터 정렬
		MergeSort(arr,mid+1,right); // mid+1 ~ right에 위치한 데이터 정렬
	
		// 정렬된 두 배열을 병합
		MergeTwoArea(arr,left,mid,right);
	}
}

// 병합을 위한 함수

void MergeTwoArea(int arr[],int left,int mid, int right){
	int fIdx = left; 
	int rIdx = mid+1;
	int i;
	int * sortArr = (int*)malloc(sizeof(int)*(right+1));
	int sIdx = left;

	while(fIdx <= mid && rIdx <=right){
		if(arr[fIdx] <=arr[rIdx])
			sortArr[sIdx] = arr[fIdx++];
		else 
			sortArr[sIdx] = arr[rIdx++];
		sIdx++;
	}
	if(fIdx > mid){
		for(i=rIdx;i<=right;i++,sIdx++)
			sortArr[sIdx] = arr[i];
	}else{
		for(i=fIdx;i<=mid;i++,sIdx++)
			sortArr[sIdx] = arr[i];
	}
	for(i=left;i<=right;i++)
		arr[i] = sortArr[i];
	free(sortArr);
}

https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html



병합정렬 성능 평가

Divide and Conquer

분할 과정  = log2N

병합 과정 -> 
비교 연산의 과정 =  N번  

이동 연산 = N번 


N*N*log2N = 2nlog2n 이므로 

따라서 빅-오는  O(nlogn) 이다


퀵 정렬 : 이해 
- 1단계 : 초기화
left : 정렬대상의 왼쪽 지점
right : 정렬대상의 오른쪽 지점
pivot : 중심축 지점
low : 피벗을 제외한 가장 왼쪽에 위치한 지점
high : 피벗을 제외한 가장 오른쪽에 위치한 지점

- 2단계
low는 오른쪽으로 이동 -> 피벗보다 큰값을 만날 때까지
high는 왼쪽으로 이동 -> 피벗보다 작은 값을 만날 때까지

- 3단계
low와 high의 데이터 교환

이후, 지속해서 이동(high와 low가 역전될때까지)
역전되면 멈춘다.

- 4단계
high와 low가 역전되면, 피벗과 high의 데이터 교환
(여기까지가 1회전)

피봇위치를 기점으로 두개의 영역으로 나누어 반복 실행


left>right 일때까지 반복
