우선순위 큐(Priority Queue)

트리의 연장선상으로 바라볼수 있음. (힙 Heap)

입구에 들어가는 순서에 상관 없이 

우선순위가 높은 순으로 출구로 빠져나오는 형태

우선순위 큐의 두가지 연산
enqueue 우선순위 큐에 데이터를 삽입하는 행위
dequeue 우선순위 큐에서 데이터를 꺼내는 행위
들어간 순서에 상관 없이 우선순위를 근거로 dequeue 연산이 진행됨.

직접 우선순위 비교기준을 결정할 수 있도록 구현되어야 한다.

우선순위 큐의 구현 방법
배열을 기반으로 구현하는 방법
연결 리스트를 기반으로 구현하는 방법
힙(heap)을 이용하는 방법

배열/연결 리스트인 경우 , 구현이 쉽다.  // 단, 성능이 떨어진다. (worst case 에 가까울 경우) 
(새 데이터의 우선순위에 따라 집어넣을 위치를 찾아 넣어주면됨)
배열기반인 경우, input 시, 우선순위가 알맞은 인덱스를 찾아 그 인덱스를 한칸씩 뒤로 밀어준다.
연결리스트인 경우, iunput 시, 해당 위치에 연결 해주면됨.


heap을 이용하는 방법
구현은 까다로우나, 위의 성능은 우수하다.

힙(heap)의 소개

힙은 완전 이진 트리이다.
모든 노드에 저장된 값은 자식 노드에 저장된 값보다 크거나 같아야 한다.
즉, 루트 노드에 저장된 값이 가장 커야 한다. (최대 힙 : max heap)
      리프노드에 있는 값이 가장 커야 한다. (최소 힙 : min heap)

힙의 데이터 저장/삭제과정이 이해하기 생각보다 어렵다.

- 힙의 데이터 저장 과정(규칙)
오름차순 정렬 기준  

완전 이진 트리 이면서 자식노드 데이터의 우선순위 <= 부모 노드 데이터의 우선순위 (힙)

1. 우선은 리프노드에 데이터를 저장.
2. 부모노드와의 우선순위를 비교한 후 자리 바꿈
    (이를 계속 반복해서 자리를 찾는다.)

- 힙에서의 데이터 삭제 과정(규칙) -> dequeue
루트노드 기준
1. 루트를 삭제(비움)
2. 리프노드를 루트 노드로 이동
3. 부모노드와 자식 노드를 비교하여 자리 이동을 시킨다.(단 left와 right 중 큰놈과만 비교하면 됨)
